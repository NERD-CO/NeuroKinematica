function run_PCA_ZETA_byCategory(MasterZETA)

% run_PCA_ZETA_byCategory
%
% Do PCA on ZETA temporal deviation vectors (Zeta_vecD) for each
% MoveType × STN depth, after resampling onto a common time axis given by
% PSTH_TimeCenters_s.
%
% Then plot PC1 per MoveType for each Depth (3 rows: t/c/b).


%% Load MasterZETA_AllData (produced by aggregate_ZETA_and_plot)

% if nargin < 1
%     masterZETA_mat = 'MasterZETA_AllData.mat';
% end
% S = load(masterZETA_mat, 'MasterZETA');
% MasterZETA = S.MasterZETA;

fprintf('[OK] Loaded MasterZETA_AllData: %d total entries\n', height(MasterZETA));

% --- Sanity check required columns ---
reqVars = {'MoveType','Depth','ZETA_vecD','ZETA_vecT','PSTH_TimeCenters_s','SpikeField','PrettyLabel'};
missing = setdiff(reqVars, MasterZETA.Properties.VariableNames);
if ~isempty(missing)
    error('MasterZETA is missing required variables: %s', strjoin(missing,', '));
end


%% Extract needed fields

MoveTypes = MasterZETA.MoveType;
Depths    = MasterZETA.Depth;

ZetaZ = MasterZETA.ZetaZ;
ZetaD = MasterZETA.ZETA_vecD;      % cell array (temporal deviation)
ZetaT = MasterZETA.ZETA_vecT;      % cell array (time support for vecD)

% PSTH time (uniform across subjects; already verified)
PSTH_time = MasterZETA.PSTH_TimeCenters_s;


%%

% Restrict to rows that have both ZETA vecD and PSTH time centers
hasZ = ~cellfun(@isempty, MasterZETA.ZETA_vecD);
hasT = ~cellfun(@isempty, MasterZETA.PSTH_TimeCenters_s);
M = MasterZETA(hasZ & hasT, :);

if isempty(M)
    error('No rows with both Zeta_vecD and PSTH_TimeCenters_s found.');
end

fprintf('[OK] Unique MoveTypes: %s\n', strjoin(unique(M.MoveType,'stable'), ', '));

moveTypes  = unique(M.MoveType,'stable');
depths     = {'t','c','b'};  % keep STN order dorsal->central->ventral
depthNames = containers.Map({'t','c','b'}, ...
                            {'dorsal STN','central STN','ventral STN'});

% Colors by MoveType
mtColor = containers.Map( ...
    {'HAND OC','HAND PS','ARM EF','REST'}, ...
    {[0.95 0.60 0.10], ... % Hand OC = orange
     [0.20 0.65 0.30], ... % Hand PS = green
     [0.15 0.45 0.85], ... % Arm EF  = blue
     [0.60 0.60 0.60]});   % Rest    = gray

% Storage for PC1 waveforms per MoveType × Depth
PC1 = struct();
for d = 1:numel(depths)
    for m = 1:numel(moveTypes)
        key = sprintf('%s|%s', depths{d}, moveTypes{m});
        PC1.(key).t   = [];
        PC1.(key).pc1 = [];
        PC1.(key).nUnits = 0;
    end
end

% ----- MAIN LOOP: per MoveType × Depth -----
for d = 1:numel(depths)
    dz = depths{d};

    for m = 1:numel(moveTypes)
        mv = moveTypes{m};

        catRows = M(M.MoveType==mv & M.Depth==dz, :);
        if height(catRows) < 2
            % Not enough units in this category to do PCA
            continue;
        end

        % --- Reference time axis from PSTH_TimeCenters_s (first valid row) ---
        t_ref = catRows.PSTH_TimeCenters_s{1};
        if isempty(t_ref) || ~isnumeric(t_ref)
            warning('Empty or non-numeric PSTH_TimeCenters_s for %s × %s; skipping.', mv, dz);
            continue;
        end
        t_ref = t_ref(:);  % column vector

        nUnits = height(catRows);
        X = nan(numel(t_ref), nUnits);  % time × units

        keepUnit = false(1, nUnits);   % which units we actually use

        for u = 1:nUnits
            dVec = catRows.Zeta_vecD{u};
            tZ   = catRows.Zeta_vecT{u};

            if isempty(dVec) || isempty(tZ), continue; end
            dVec = double(dVec(:));
            tZ   = double(tZ(:));

            if numel(dVec) < 3 || numel(tZ) ~= numel(dVec)
                continue;
            end

            % Interpolate ZETA deviation (dVec) onto common PSTH time base
            try
                X(:,u) = interp1(tZ, dVec, t_ref, 'linear', 'extrap');
                keepUnit(u) = true;
            catch ME
                warning('interp1 failed for unit %d in %s × %s: %s', ...
                        u, mv, dz, ME.message);
            end
        end

        % Keep only columns with actual data
        X = X(:, keepUnit);
        if size(X,2) < 2
            % need at least 2 units to meaningfully do PCA
            continue;
        end

        % Remove timepoints that are NaN across all units
        goodTime = any(isfinite(X), 2);
        X = X(goodTime, :);
        t_use = t_ref(goodTime);

        % Replace remaining NaNs (per unit) with unit-wise mean over non-NaN times
        for j = 1:size(X,2)
            nanMask = ~isfinite(X(:,j));
            if any(nanMask)
                mu_j = mean(X(~nanMask,j), 'omitnan');
                X(nanMask,j) = mu_j;
            end
        end

        % ----- PCA -----
        % PCA expects observations = rows, variables = columns.
        % We want temporal patterns as variables, units as observations:
        %   rows = units, columns = timepoints -> X' (units × time)
        [coeff, score, latent] = pca(X', 'Centered', true);

        % coeff: [nTime × nPC], columns are PCs across time
        pc1 = coeff(:,1);  % time course of PC1

        % Flip sign so that the mean of PC1 in the post-onset window is positive
        postMask = t_use >= 0 & t_use <= (max(t_use) * 0.5);
        if any(postMask)
            if mean(pc1(postMask)) < 0
                pc1 = -pc1;
                score(:,1) = -score(:,1);
            end
        end

        key = sprintf('%s|%s', dz, mv);
        PC1.(key).t      = t_use;
        PC1.(key).pc1    = pc1;
        PC1.(key).nUnits = size(X,2);
        PC1.(key).latent = latent;
        PC1.(key).scores = score;
        PC1.(key).labels = catRows.PrettyLabel(keepUnit);

        fprintf('[PCA] %s × %s: %d units, %d time points\n', mv, dz, size(X,2), numel(t_use));
    end
end

% ----- PLOT: PC1 per depth (rows) and MoveType (colors) -----

% pick consistent MoveType plotting order
mtOrder = {'HAND OC','HAND PS','ARM EF','REST'};
mtOrder = intersect(mtOrder, moveTypes, 'stable');

hFig = figure('Color','w','Position',[100 100 950 800]);
tlo = tiledlayout(3,1,'TileSpacing','compact','Padding','compact');

for d = 1:numel(depths)
    dz = depths{d};
    ax = nexttile; hold(ax,'on'); grid(ax,'on');

    for m = 1:numel(mtOrder)
        mv = mtOrder{m};
        key = sprintf('%s|%s', dz, mv);
        if ~isfield(PC1, key), continue; end
        if isempty(PC1.(key).t), continue; end

        t_use = PC1.(key).t;
        pc1   = PC1.(key).pc1;

        % color
        if isKey(mtColor, mv)
            c = mtColor(mv);
        else
            c = [0.5 0.5 0.5];
        end

        plot(ax, t_use, pc1, 'LineWidth', 2, 'Color', c, 'DisplayName', mv);
    end

    xlabel(ax, 'Time from movement onset (s)');
    ylabel(ax, 'PC1 (a.u.)');
    if isKey(depthNames, dz)
        title(ax, sprintf('PC1 of ZETA deviation | %s', depthNames(dz)));
    else
        title(ax, sprintf('PC1 of ZETA deviation | depth %s', dz));
    end

    xline(ax, 0, 'k--', 'LineWidth', 1);
end

% Global legend (once)
lgd = legend(tlo.Children(end), mtOrder, 'Location','eastoutside');
title(tlo, 'PC1 of ZETA temporal deviation per MoveType × STN depth');

end


%% -------------------------------------------------------------
function lbl = depthLabel(dz)
switch dz
    case 't'; lbl = 'dorsal';
    case 'c'; lbl = 'central';
    case 'b'; lbl = 'ventral';
    otherwise; lbl = dz;
end
end
