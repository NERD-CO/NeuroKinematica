function All_SpikesPerMove_Tbl_MUA = align_MUA_perMove_TTL(All_SpikesPerMove_Tbl, ProcDataDir, AO_spike_fs, pre_offset_ms, Case_FRKin_Dir);

% > align_MUA_perMove_TTL

% Align IO MUA data segments with corresponding movement data segments per trial


%% Load All_SpikesPerMove_Tbl

cd(Case_FRKin_Dir)
Tbl_list = dir('*Spikes*.mat');
Tbl_names = {Tbl_list.name};
case_mat = Tbl_names{contains(Tbl_names, 'offset')}; % offset version preferred
load(case_mat, 'All_SpikesPerMove_Tbl');


%% --- Add MUA per move (for E1 -> C1_MUA / C1_MUA_ts) ---

% Go to 'Processed Electrophysiology' dir (may include hemisphere)
cd(ProcDataDir)

% Add to copy of the base table, don't mutate original
All_SpikesPerMove_Tbl_MUA = All_SpikesPerMove_Tbl;

% Prep output columns (cell columns)
if ~ismember('C1_MUA', All_SpikesPerMove_Tbl_MUA.Properties.VariableNames)
    All_SpikesPerMove_Tbl_MUA.C1_MUA    = cell(height(All_SpikesPerMove_Tbl_MUA),1);
end
if ~ismember('C1_MUA_ts', All_SpikesPerMove_Tbl_MUA.Properties.VariableNames)
    All_SpikesPerMove_Tbl_MUA.C1_MUA_ts = cell(height(All_SpikesPerMove_Tbl_MUA),1);
end

%% Main loop

% Iterate by unique spike files to avoid loading repeatedly
uniqSpkFiles = unique(All_SpikesPerMove_Tbl_MUA.spike_trial_ID, 'stable');

for mat_f = 1:numel(uniqSpkFiles)
    temp_Spk_mat = string(uniqSpkFiles{mat_f});
    if strlength(temp_Spk_mat)==0, continue; end

    % Load the spike file
    Spk_mat = load(temp_Spk_mat);
    SPIKE_struct = Spk_mat.ProcEphys.Spike;


    % % loop through electrodes (E1 ... En)
    % elecNames = fieldnames(SPIKE_struct);
    % num_E = numel(elecNames); % number of electrodes
    % for e_i = 1:num_E
    %     e_name = elecNames{e_i};
    %     if ~isfield(SPIKE_struct.(e_name),'rawData') || isempty(SPIKE_struct.(e_name).rawData), continue; end

    % % Extract raw signal per electrode and ensure it's a double
    % % spikeDataRaw = SPIKE_struct.(['E', num2str(e_i)]).rawData;
    % spikeDataRaw = double(SPIKE_struct.(e_name).rawData);

    % % Extract sampling rate
    % % spkFS = SPIKE_struct.(['E', num2str(e_i)]).Hz*1000; % AO_spike_fs = 44 kHz
    % spkFS = SPIKE_struct.(e_name).Hz*1000; % AO_spike_fs = 44 kHz


    % Find all rows in table that use this spike file
    rowIdx = find(string(All_SpikesPerMove_Tbl_MUA.spike_trial_ID) == temp_Spk_mat);

    % ---- Extract MUA from E1 once for the whole file ----
    if ~isfield(SPIKE_struct,'E1') || ~isfield(SPIKE_struct.E1,'rawData') || isempty(SPIKE_struct.E1.rawData)
        % fill empties for all rows that reference this file
        for r = rowIdx'
            All_SpikesPerMove_Tbl_MUA.C1_MUA{r}    = [];
            All_SpikesPerMove_Tbl_MUA.C1_MUA_ts{r} = [];
        end
        continue
    end

    % Extract raw signal and sampling rate
    spikeDataRaw = double(SPIKE_struct.E1.rawData); % ensure it's a double
    spkFS = SPIKE_struct.E1.Hz*1000; % AO_spike_fs = 44 kHz

    % Robust noise estimate (MAD) -> sigma ~= 1.4826*MAD
    % For a zero-mean Gaussian, MAD = median(âˆ£ð‘‹âˆ’median(ð‘‹)âˆ£)=ðœŽ*(Î¦^âˆ’1)(0.75)â‰ˆ0.6745ðœŽ, so: Ïƒ = MAD/0.6745 = 1.4826*MAD
    sigma = 1.4826 * median(abs(spikeDataRaw - median(spikeDataRaw)));

    % MUA-tuned params (more lenient than S.U.)
    kThr      = 3.0;           % 3.0â€“3.5 is reasonable for MUA
    minDistMs = 0.6;           % 0.6â€“1.0 ms
    minDist   = max(1, round(spkFS * (minDistMs/1000)));

    % Auto-polarity: count detections on both signs and pick the richer side
    thrPos =  +kThr*sigma;
    thrNeg =  -kThr*sigma;

    % Positive peaks
    [~, locsPos] = findpeaks(spikeDataRaw, 'MinPeakHeight', thrPos, 'MinPeakDistance', minDist);

    % Negative peaks (invert to use findpeaks)
    [~, locsNeg] = findpeaks(-spikeDataRaw, 'MinPeakHeight', -thrNeg, 'MinPeakDistance', minDist);

    % Choose polarity with more detections
    if numel(locsNeg) > numel(locsPos)
        peakIdx = locsNeg(:);   % negative-deflection spikes
    else
        peakIdx = locsPos(:);   % positive-deflection spikes
    end


    % Set Thresholds
    thresh = (round(std(spikeDataRaw) * 4) + mean(spikeDataRaw)); % detection threshold
    noise = (round(std(spikeDataRaw) * 10) + mean(spikeDataRaw)); % noise bound
    minDist = round(spkFS/1000) * 0.6; % was 1.5 ms refreactory (samples)
    PNFLAG = 1;

    % Detect MUA from raw spike data using waveform extractor helper function
    [ waveData ] = extractWaveforms_Clz_v07(spikeDataRaw, thresh, noise, minDist, spkFS, PNFLAG);
    waveForms = waveData; % MUA (unsorted spikes) that exeed thresholds
    peakIdx = waveData.allWavesInfo.alllocs; % MUA spike sample indices ("peak" indices)


    % ---- Window & store MUA per row (trial/move) ----
    for r = rowIdx'
        t0 = All_SpikesPerMove_Tbl_MUA.TTL_spk_idx_Start(r);
        t1 = All_SpikesPerMove_Tbl_MUA.TTL_spk_idx_End(r);

        % Ensure integers & valid order
        if ~isfinite(t0) || ~isfinite(t1) || isempty(peakIdx)
            All_SpikesPerMove_Tbl_MUA.C1_MUA{r}    = [];
            All_SpikesPerMove_Tbl_MUA.C1_MUA_ts{r} = [];
            continue
        end
        t0 = max(1, round(t0));
        t1 = max(t0, round(t1));

        % Keep MUA peaks within this row's AO-sample window
        inWin = (peakIdx >= t0) & (peakIdx <= t1);
        idxWin = peakIdx(inWin);

        % Convert time to seconds relative to row start (match C1_ts convention)
        relSec = (idxWin - t0) / spkFS - (pre_offset_ms/1000);

        All_SpikesPerMove_Tbl_MUA.C1_MUA{r}    = idxWin;  % AO sample indices
        All_SpikesPerMove_Tbl_MUA.C1_MUA_ts{r} = relSec;  % seconds relative to row's start
    end     % per row

    % end         % per electrode

end             % per ProcEphys file

%% Save new table

% Save alongside your spikes-per-move table
outName = 'All_Spikes_n_MUAperMove_tbl.mat';
save(fullfile(Case_FRKin_Dir, outName), 'All_SpikesPerMove_Tbl_MUA');
fprintf('[OK] Wrote %s with C1_MUA/C1_MUA_ts columns.\n', fullfile(Case_FRKin_Dir, outName));

%%

