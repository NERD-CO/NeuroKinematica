%% Order_of_Op__LFPKin_Processing

clear; close all; clc;

%% Environment / Directory Set-up

% specify directory where case-specific data files are located
curPCname = getenv('COMPUTERNAME');

switch curPCname
    case 'DESKTOP-I5CPDO7'  % PC_1
        IO_DataDir = 'X:\RadcliffeE\Thesis_PD Neuro-correlated Kinematics\Data\Intraoperative';
    case 'DSKTP-JTLAB-EMR'  % Lab Desktop
        IO_DataDir = 'Z:\RadcliffeE\Thesis_PD Neuro-correlated Kinematics\Data\Intraoperative';
        addpath 'C:\Users\erinr\OneDrive - The University of Colorado Denver\Documents 1\GitHub\NeuroKinematica\IO_LFP_Analysis'
    case 'NSG-M-H8J3X34'    % PC_2
        IO_DataDir = 'Z:\RadcliffeE\Thesis_PD Neuro-correlated Kinematics\Data\Intraoperative';
        addpath 'C:\GitHub\NeuroKinematica\IO_LFP_Analysis'
end

cd(IO_DataDir)
Subject_AO = readtable('Subject_AO.xlsx');


%% Config - Define datastream sampling rates (Alpha Omega and Video sampling fs)

TTL_fs = 44000;         % Hz, Alpha Omega TTL clock
AO_spike_fs = 44000;    % Hz, Alpha Omega spike sampling rate
AO_LFP_fs = 1375;       % Hz, Alpha Omega LFP sampling rate
DLC_fs = 100;           % fps, Video/DLC frame rate


%% Config - Define offset duration for useOffset_LFP function

pre_offset_ms = 50; % milliseconds
offset_seconds = pre_offset_ms / 1000; % seconds

% Calculate number of TTL samples
offset_TTLs = round(TTL_fs * offset_seconds); % ensure value is integer

% Calculate number TTL samples in AO_LFP sample domain by downsampling TTL_fs
offset_LFPs = round((offset_TTLs/TTL_fs)*AO_LFP_fs); % ensure value is integer

useOffset = true;
% If useOffset == true or pre_offset_ms>0, useOffset_LFP function returns the #
% of samples to pre-pad in LFP domain based on a set pre-trial offset time
% (and a meta struct for reference).
% If useOffset == false or pre_offset_ms<=0, useOffset_LFP function returns 0.

%% Config - Define epoch duration for UniformEpochs_LFP function

epochDur_ms = 1000; % milliseconds
Epoch_dur_seconds = epochDur_ms / 1000; % seconds

% Calculate number of TTL samples
epochDur_TTLs = round(TTL_fs * Epoch_dur_seconds); % ensure value is integer

% Calculate number TTL samples in AO_LFP sample domain by downsampling TTL_fs
epochDur_LFPs = round((epochDur_TTLs/TTL_fs)*AO_LFP_fs); % ensure value is integer

UniformEpochs = true;
% If UniformEpochs == true or epochDur_ms > 0, useOffset_LFP function returns the #
% of samples to pre-pad in LFP domain based on a set pre-trial offset time
% (and a meta struct for reference).
% If UniformEpochs == false or epochDur_ms <= 0, useOffset_LFP function returns 0.


%% Config - Ephys Case Input

% isolate a specific CaseDate / studyID (StudyNum in Subject_AO csv)
CaseDate = '03_23_2023';

% '03_09_2023'; % studyID = 1, ptID 1

% '03_23_2023'; % studyID = 2, ptID 2    * % Use for INS 2026
% '04_05_2023'; % studyID = 3, ptID 2    * % Use for INS 2026

% '04_13_2023_bilateral'; ptID 3
% studyID = 4(L), 5(R),

% '05_11_2023'; % studyID = 6, ptID 4
% '05_18_2023_a'; % studyID = 7, ptID 4

% '05_18_2023_b_bilateral';
% LSTN: studyID = 8, ptID = 5    % Use for INS 2026
% RSTN: studyID = 9, ptID = 5

% '05_31_2023';  % studyID = 10, ptID 6

% '06_08_2023_bilateral'; ptID = 7
% LSTN: studyID = 11,
% RSTN: studyID = 12(R),

% '07_13_2023_bilateral';
% studyID = 15(L), 16(R), ptID = 9


%% Config - Movement Case Input

% Specify case ID
Move_CaseID = 'IO_03_23_2023_LSTN';

% 'IO_03_09_2023_RSTN'; % studyID = 1, ptID 1 (processed, incomplete case)

% 'IO_03_23_2023_LSTN'; % studyID = 2, ptID 2 (processed, complete case) *
% 'IO_04_05_2023_RSTN'; % studyID = 3, ptID 2 (processed, complete case) *

% 'IO_04_13_2023_LSTN'; % studyID = 4, ptID 3 (processed, complete case)
% 'IO_04_13_2023_RSTN'; % studyID = 5, ptID 3

% 'IO_05_11_2023_LSTN'; % studyID = 6, ptID 4 (processed, incomplete case)
% 'IO_05_18_2023_a_RSTN'; % studyID = 7, ptID 4

% 'IO_05_18_2023_b_LSTN'; % studyID = 8, ptID 5 (processed, complete case) *
% 'IO_05_18_2023_b_RSTN'; % studyID = 9, ptID 5

% 'IO_05_31_2023_LSTN'; % studyID = 10, ptID 6

% 'IO_06_08_2023_LSTN'; % studyID = 11, ptID = 7 (processed, complete case)
% 'IO_06_08_2023_RSTN'; % studyID = 12, ptID = 7 (processed, incomplete case)

% 'IO_07_13_2023_LSTN'; % studyID = 15, ptID = 9
% 'IO_07_13_2023_RSTN'; % studyID = 16, ptID = 9


%% Config - Input and Output Data Dirs

Case_DataDir = [IO_DataDir, filesep, CaseDate];
MoveDataDir = [IO_DataDir, filesep, 'Processed DLC'];

% Case-specific Input dirs
ProcDataDir = [Case_DataDir, filesep, 'Processed Electrophysiology'];       % directory for processed ephys data and spike clusters
Move_CaseDir = [MoveDataDir, filesep, Move_CaseID];                         % directory for processed DLC data and Movement Indices

% Case-specific Output dir
ephysTbl_Dir = [Case_DataDir, filesep, 'DLC_Ephys'];                        % directory where all ephys per move-rep tables are located


%% Config - Handle bilateral cases and hemisphere selection
% create metadata sheet to pull from (for future users)

isBilateral = contains(CaseDate, 'bilateral', 'IgnoreCase', true);

if isBilateral
    fprintf('[INFO] Bilateral case detected: %s\n', CaseDate);

    % Prompt user for hemisphere choice (LSTN or RSTN)
    CaseDate_hem = input('Enter hemisphere (LSTN or RSTN): ', 's');

    % Validate input
    validHems = {'LSTN','RSTN'};
    if ~ismember(CaseDate_hem, validHems)
        error('Invalid input. Please enter LSTN or RSTN.');
    end
else
    CaseDate_hem = ''; % No hemisphere for unilateral cases
end

% Append hemisphere folder if needed
if ~isempty(CaseDate_hem)
    ProcDataDir = fullfile(ProcDataDir, CaseDate_hem);
    fprintf('[INFO] Hemisphere-specific input ephys directory set: %s\n', ProcDataDir);
    ephysTbl_Dir = fullfile(ephysTbl_Dir, CaseDate_hem);
    fprintf('[INFO] Hemisphere-specific output directory set: %s\n', ephysTbl_Dir);

else
    fprintf('[INFO] Using base ephys input directory: %s\n', ProcDataDir);
    fprintf('[INFO] Using base output directory: %s\n', ephysTbl_Dir);
end



%% ------ Functions ------

%% Run align_LFPsPerMove_TTL function

% All_LFPsPerMove_Tbl = align_LFPsPerMove_TTL(Subject_AO, ProcDataDir, Move_CaseDir, ephysTbl_Dir, TTL_fs, AO_LFP_fs, pre_offset_ms, useOffset);

%% Run align_LFPsPerMove_uniformEpochDur function

% Add 500-1000 ms from start of each MoveRep

% All_LFPsPerMove_Tbl_uniformEpochs = align_LFPsPerMove_uniformEpochDur(Subject_AO, ProcDataDir, Move_CaseDir, ephysTbl_Dir, TTL_fs, AO_LFP_fs, pre_offset_ms, useOffset, UniformEpochs, epochDur_ms);
[All_LFPsPerMove_Tbl_uniformEpochs, meta_Offset, meta_epochDur] = align_LFPsPerMove_uniformEpochDur(Subject_AO, ProcDataDir, Move_CaseDir, ephysTbl_Dir, TTL_fs, AO_LFP_fs, pre_offset_ms, useOffset, UniformEpochs, epochDur_ms);

% meta structs (ms, sec, ttl_samp, lfp_samp):
% meta_Offset    :  pre-trial offset from start of rep 
% meta_epochDur  :  post-trial duration from start rep


%% Inputs for spectrumInterpolation (Miguel's function :))

% This function interpolates around the frequency of interest (Fl) and
% replaces its and some neighbors using a constant value.

% function inputs
% data = All_LFPsPerMove_Tbl_uniformEpochs.LFP; % data: column vector of the data that needs to be filtered
Fs = AO_LFP_fs; % Fs: Sampling Frequency (in Hz) of the data, % loop on harmonics of 60 Hz
Fl = 60; % Fl: Line frequency (in Hz), center of our interpolation, loop on harmonics of 60 Hz (notch & comb)
neighborsToSample = 4; % Hz, 4 or 5
neighborsToReplace = 2; % Hz, 1 or 2

% neighborsToSample: This parameter is in Hz, and tells this function how
% large of a window (in Hz) to use when picking the constant value to
% replace frequency content with.

% neighborsToReplace: This parameter is also in Hz, and tells this function
% which neighbors need to be replaced with the constant value that was
% determined by neighborsToSample. Generally, neighborsToReplace <
% neighborsToSample in order to get a better spectral estimate.


%% Run wrapper_applySpectrumInterpolation_LFPs function

% pick which columns to filter (LFP channels) ---
LFPsPerMoveTbl_vars = string(All_LFPsPerMove_Tbl_uniformEpochs.Properties.VariableNames);
lfpCols = LFPsPerMoveTbl_vars(startsWith(LFPsPerMoveTbl_vars,"LFP_E"));     % e.g., LFP_E1, LFP_E2, ...

% create new columns with "_filt" after running each through spectrumInterpolation
makeNewCols = true;

% run wrapper function for spectrumInterpolation and output updated All_LFPsPerMove_Tbl
All_LFPsPerMove_Tbl_specIfilt = wrapper_applySpectrumInterpolation_LFPs(All_LFPsPerMove_Tbl_uniformEpochs, ...
    lfpCols, AO_LFP_fs, Fl, neighborsToSample, neighborsToReplace, ...
    makeNewCols);


%% save All_LFPsPerMove_Tbl with LFP_E column vectors filtered by spectrumInterpolation

cd(ephysTbl_Dir)

if useOffset && pre_offset_ms > 0 && UniformEpochs && epochDur_ms > 0
    specI_filt_outName = sprintf('specI_All_LFPsPerMove_pre%ims_post%ims.mat', pre_offset_ms, epochDur_ms);
else
    specI_filt_outName = 'specI_All_LFPsPerMove_N0offset.mat';
end

save(specI_filt_outName, "All_LFPsPerMove_Tbl_specIfilt");


%% filters (notes)

% 1) high-pass at 0.5 or 1 Hz
% low freq. noise + drift removal
% use designfilt + filtfilt

% 1) low-pass at 250 Hz            
% anti-alias + keep LFP band 
% use designfilt + filtfilt

% 3) downsample / resample 1375 to 500 Hz

% Question (in initial notes)
% 1-3 kHz (?)


%% Filtering (after spectrumInterpolation)

% Input:  All_LFPsPerMove_Tbl_specIfilt (with LFP_E*_filt columns, Fs = 1375 Hz)
% Output: Preprocessed vectors (high-pass, low-pass, downsampled to 500 Hz)

fs_AO  = AO_LFP_fs;   % original LFP sampling rate = 1375 Hz
fs_downsamp = 500;    % downsampled rate = 500 Hz

fs_AO_Nyquist = fs_AO./2;       % 687.5 Hz
fs_DS_Nyquist = fs_downsamp./2; % 250 Hz

% Resampling Ratio
resamp_Ratio = fs_downsamp./fs_AO; % (new_fs/orig_fs) = 500/1375  =  0.3636

% Get the rational approximation
[up_factor, down_factor] = rat(resamp_Ratio); % 4/11
disp(['Resampling Ratio, Fractional Representation: ', num2str(up_factor), '/', num2str(down_factor)]);


% Design filters (once)
hpFilt = designfilt('highpassiir', ...
    'FilterOrder', 4, ...
    'HalfPowerFrequency', 1, ...      % highpass at ~1 Hz
    'SampleRate', fs_AO);

lpFilt = designfilt('lowpassiir', ...
    'FilterOrder', 8, ...
    'HalfPowerFrequency', 250, ...    % lowpass at 250 Hz (or ~200–230 Hz)
    'SampleRate', fs_AO);

% Pick which columns to filter (post-spectrumInterpolation: '_filt')
lfpCols_filt = string(All_LFPsPerMove_Tbl_specIfilt.Properties.VariableNames);
lfpCols_filt = lfpCols_filt(startsWith(lfpCols_filt,"LFP_E") & endsWith(lfpCols_filt,"_filt"));

% Loop through each LFP column and row
for col_i = 1:numel(lfpCols_filt)
    colName = lfpCols_filt(col_i);
    proc_col_outName = replace(colName,"_filt","_proc500");  % output column name

    % Preallocate
    All_LFPsPerMove_Tbl_specIfilt.(proc_col_outName) = cell(height(All_LFPsPerMove_Tbl_specIfilt),1);

    for row_i = 1:height(All_LFPsPerMove_Tbl_specIfilt)
        LFP_vec = All_LFPsPerMove_Tbl_specIfilt.(colName){row_i};
        if isempty(LFP_vec) || ~isnumeric(LFP_vec) || ~isvector(LFP_vec)
            All_LFPsPerMove_Tbl_specIfilt.(proc_col_outName){row_i} = LFP_vec;
            continue
        end

        % Filtering steps
        LFP_vec = double(LFP_vec(:));                                       % ensure column, double
        LFP_vec_hp = filtfilt(hpFilt, LFP_vec);                             % high-pass, lowF drift removal
        LFP_vec_lp = filtfilt(lpFilt, LFP_vec_hp);                          % low-pass anti-alias
        LFP_vec_downsamp = resample(LFP_vec_lp, up_factor, down_factor);    % downsample 1375 → 500 Hz (resamp ratio = 4/11)

        % Store result
        All_LFPsPerMove_Tbl_specIfilt.(proc_col_outName){row_i} = LFP_vec_downsamp;
    end
end


%% Visualization (Quality check)

testRow = 6;   % change index to preview other trials
raw_LFP_vec   = All_LFPsPerMove_Tbl_specIfilt.(lfpCols_filt(1)){testRow};
proc_LFP_vec  = All_LFPsPerMove_Tbl_specIfilt.(replace(lfpCols_filt(1),"_filt","_proc500")){testRow};


% fs_AO = AO_LFP_fs; % 1375 Hz
t_step_AO = 1/fs_AO;
ts_LFP_AO = 0:t_step_AO:(length(raw_LFP_vec)-1)/fs_AO;

% fs_downsamp = 500; % 500 Hz
t_step_proc = 1/fs_downsamp;
ts_LFP_proc = 0:t_step_proc:(length(proc_LFP_vec)-1)/fs_downsamp;

% visualize
figure;
subplot(2,1,1);
plot(ts_LFP_AO, raw_LFP_vec); title('LFP (post spectrumInterpolation, 1375 Hz)');
xlabel('Time (s)');
ylabel('Preprocessed LFP (uV or unscaled)');
subplot(2,1,2);
plot(ts_LFP_proc, proc_LFP_vec); title('Filtered & Processed LFP (post hpfilt + lpfilt + downsampling, 500 Hz)');
xlabel('Time (s)');
ylabel('Processed LFP (uV or unscaled)');


%% Questions 

% 1) Why/how are the y-axis magnitudes this different? 
% is this ok/expected or is there something wrong in my filtering methods?

% 2) Are the LFP units in microVolts (uV) and being plotted as such,
% or are the y-axis units different/unscaled?

% 3) Do I need to adjust the lowpass cutoff from 250 Hz to ~200–230 Hz 
% to be below the Nyquist of the downsampled fs (500 Hz)? 


%% Plot Power Spectral Density of Raw LFP (post spectrumInterpolation)

% compute power spectral density (PSD) of LFP segment(s) - pspectrum function
[rawPxx,rawFxx] = pspectrum(raw_LFP_vec,fs_AO,'FrequencyLimits',[0 90],'FrequencyResolution', 3); 

figure;
pspectrum(raw_LFP_vec,fs_AO,"power",'FrequencyLimits',[0 90],'FrequencyResolution', 3) % 2 or 3

% normalize using the common logarithm via decibel conversion - pow2db function
rawPxx_db = pow2db(rawPxx);

% plot PSD for visualization
figure;
%plot(freq, 10*log10(power));
plot(rawFxx, rawPxx_db);
xlim([0 80]) 
xlabel('Frequency (Hz)');
ylabel('Power (dB)');
title('Power Spectral Density of Raw LFP (post spectrumInterpolation)');


%% Plot Power Spectral Density of Processed LFP (post hpfilt + lpfilt + downsampling, 500 Hz)

% compute power spectral density (PSD) of LFP segment(s) - pspectrum function
[procPxx,procFxx] = pspectrum(proc_LFP_vec,fs_downsamp,'FrequencyLimits',[0 100],'FrequencyResolution', 3); 

figure;
pspectrum(proc_LFP_vec,fs_downsamp,"power",'FrequencyLimits',[0 100],'FrequencyResolution', 3) % 2 or 3

% normalize using the common logarithm via decibel conversion - pow2db function
procPxx_db = pow2db(procPxx);

% plot PSD for visualization
figure;
%plot(freq, 10*log10(power));
plot(procFxx, procPxx_db);
xlim([0 80]) 
xlabel('Frequency (Hz)');
ylabel('Power (dB)');
title('Power Spectral Density of Processed LFP');


%% Save fully filtered and processed LFP outputs (HP+LP+DS to 500 Hz)

% Resave All_LFPsPerMove_Tbl_filt
cd(ephysTbl_Dir)

if useOffset && pre_offset_ms > 0 && UniformEpochs && epochDur_ms > 0
    filtProc_outName = sprintf('filtProc_All_LFPsPerMove_pre%ims_post%ims.mat', pre_offset_ms, epochDur_ms);
else
    filtProc_outName = 'filtProc_All_LFPsPerMove_N0offset.mat';
end

save(filtProc_outName, "All_LFPsPerMove_Tbl_specIfilt");
fprintf('[SAVED] Processed table written to %s\n', fullfile(ephysTbl_Dir, filtProc_outName));


%% Extract processed LFP columns

% Extract LFP column names
allVars_LFPtbl     = string(All_LFPsPerMove_Tbl_specIfilt.Properties.VariableNames);
lfpCols_raw = allVars_LFPtbl(startsWith(allVars_LFPtbl,"LFP_E") & endsWith(allVars_LFPtbl,"_filt"));     % 1375 Hz, post spectrumInterpolation
lfpCols_proc= allVars_LFPtbl(startsWith(allVars_LFPtbl,"LFP_E") & endsWith(allVars_LFPtbl,"_proc500"));  % 500 Hz, fully preprocessed

if isempty(lfpCols_raw) || isempty(lfpCols_proc)
    warning('Expected LFP_E*_filt and/or LFP_E*_proc500 not found.');
end


%% Test Plots

% Pick a raw LFP_E column and its matching processed LFP_E column by name
lfp_colRaw_1375 = lfpCols_raw(1);                 % e.g., "LFP_E1_filt"
lfp_colProc_500 = lfpCols_proc(1);                % e.g., "LFP_E1_proc500"

% define single trial (row) to vizualize
test_rowIDX = 6; 

% Define STN depth of trial to test:
LFP_test_depth = 't';    % top/dorsal STN

% Define move_trial # of trial to test:
move_trial_num = '2';

% Define test trial IDS:
%for LFP_row_i = 1:height(All_LFPsPerMove_Tbl_filt)
if LFP_test_depth == 't'         % top/dorsal STN
    test_trialID = 't3_d5p5';
    LFP_t3_r1 = find(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID, test_trialID), 1, 'first'); % Extract the first row index where this is true
    LFP_t3_rn = find(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID, test_trialID), 1, 'last'); % Extract the last row index where this is true
    LFP_t3 = All_LFPsPerMove_Tbl_specIfilt.(char(lfp_colProc_500))(LFP_t3_r1:LFP_t3_rn); % Extract LFP segments for trial t3
    LFP_test_row = LFP_t3{test_rowIDX};
elseif LFP_test_depth == 'c'    % central STN
    test_trialID = 'c2_d3p48';
    LFP_c2_r1 = find(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID, test_trialID), 1, 'first'); % Extract the first row index where this is true
    LFP_c2_rn = find(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID, test_trialID), 1, 'last'); % Extract the last row index where this is true
    LFP_c2 = All_LFPsPerMove_Tbl_specIfilt.(char(lfp_colProc_500))(LFP_c2_r1:LFP_c2_rn); % Extract LFP segments for trial c2
    LFP_test_row = LFP_c2{test_rowIDX};
elseif LFP_test_depth == 'b'    % bottom/ventral STN
    test_depth = 'b';
    test_trialID = 'b2_d1p06';
    LFP_b2_r1 = find(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID, test_trialID), 1, 'first'); % Extract the first row index where this is true
    LFP_b2_rn = find(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID, test_trialID), 1, 'last'); % Extract the last row index where this is true
    LFP_b2 = All_LFPsPerMove_Tbl_specIfilt.(char(lfp_colProc_500))(LFP_b2_r1:LFP_b2_rn); % Extract LFP segments for trial b2
    LFP_test_row = LFP_b2{test_rowIDX};
end
%end



% visualize
figure;
plot(ts_LFP_proc, LFP_test_row)
xlabel('Time (s)');
ylabel('LFP amplitude (µV)');
title('Processed LFP trial segment');
grid on;


% compute power spectral density (PSD) of LFP segment(s) - pspectrum function
[Pxx,Fxx] = pspectrum(LFP_test_row, fs_downsamp,'FrequencyLimits',[0 50],'FrequencyResolution', 3);

figure;
pspectrum(LFP_test_row,fs_downsamp,"power",'FrequencyLimits',[0 50],'FrequencyResolution', 3) % 2 or 3

% normalize using the common logarithm via decibel conversion - pow2db function
Pxx_db = pow2db(Pxx);

% plot PSD for visualization
figure;
%plot(freq, 10*log10(power));
plot(Fxx, Pxx_db);
xlim([0 50])
xlabel('Frequency (Hz)');
ylabel('Power (dB)');
title('Power Spectral Density of Processed LFP');


%% Band isolation & Hilbert transformation (append column metrics)

% theta band
% Low beta bandpass (13–20 Hz)
% High beta bandpass (21-35 Hz)
% gamma band

% Uses _proc500 columns as input (Fs = 500). Creates:
%   *_<band>_bp       : band-passed signal
%   *_<band>_amp      : instantaneous amplitude (abs(hilbert))
%   *_<band>_pow      : instantaneous power (amp.^2)
%   *_<band>_zamp     : z-scored amplitude (per-trial, optional but handy)


%  bands of interest
bands = struct( ...
    'theta',   [4 7], ...
    'L_beta',  [13 20], ...
    'H_beta',  [21 35], ...
    'gamma',   [36 90], ...
    'hfo',     [130 200] ...
    );

%  find processed LFP columns
if isempty(lfpCols_proc)
    warning('No LFP_E*_proc500 columns found. Run preprocessing first.');
else
    fprintf('[INFO] Band-extraction from %d processed LFP columns.\n', numel(lfpCols_proc));
end

% Design bandpass filter (4th order Butterworth IIR, zero-phase later)
BPfilt = @(lo,hi) designfilt('bandpassiir', 'FilterOrder', 4, ...
    'HalfPowerFrequency1', lo, ...
    'HalfPowerFrequency2', hi, ...
    'SampleRate', fs_downsamp);

% Pre-build filters to avoid re-alloc
bp = struct();
fieldNames = fieldnames(bands);
for k = 1:numel(fieldNames)
    curBand = bands.(fieldNames{k});
    % clamp to Nyquist
    curBand(2) = min(curBand(2), fs_downsamp/2 - 1);
    if curBand(1) >= curBand(2)-1
        error('Band %s limits invalid after clamping.', fieldNames{k});
    end
    bp.(fieldNames{k}) = BPfilt(curBand(1), curBand(2));
end

% create output columns (cells)
nRows = height(All_LFPsPerMove_Tbl_specIfilt);
for col_i = 1:numel(lfpCols_proc)
    base = erase(lfpCols_proc(col_i), "_proc500");  % e.g., "LFP_E1"
    for k = 1:numel(fieldNames)
        band = fieldNames{k};
        All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_bp")   = cell(nRows,1);
        All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_amp")  = cell(nRows,1);
        All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_pow")  = cell(nRows,1);
        All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_zamp") = cell(nRows,1);
    end
end


% Hilbert transformation @ spec. freq. (inst. power)
% process row-by-row

for col_i = 1:numel(lfpCols_proc)
    inCol = lfpCols_proc(col_i);
    base  = erase(inCol, "_proc500");

    for row_i = 1:nRows
        LFPvec_x = All_LFPsPerMove_Tbl_specIfilt.(inCol){row_i};
        if isempty(LFPvec_x) || ~isvector(LFPvec_x) || ~isnumeric(LFPvec_x), continue; end
        LFPvec_x = double(LFPvec_x(:));
        if ~any(isfinite(LFPvec_x)), continue; end

        for k = 1:numel(fieldNames)
            band = fieldNames{k};
            try
                xbp = filtfilt(bp.(band), LFPvec_x);               % bandpassed
            catch ME
                warning('Row %d, %s (%s): bandpass failed: %s', ...
                    row_i, inCol, band, ME.message);
                continue
            end
            xa   = abs(hilbert(xbp));                       % inst. amplitude
            xp   = xa.^2;                                   % inst. power
            xz   = (xa - mean(xa,'omitnan')) ./ std(xa,0,'omitnan'); % z-amp

            All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_bp"){row_i}   = xbp;
            All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_amp"){row_i}  = xa;
            All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_pow"){row_i}  = xp;
            All_LFPsPerMove_Tbl_specIfilt.(base + "_" + band + "_zamp"){row_i} = xz;
        end
    end
end

fprintf('[DONE] Added bandpassed, amplitude, power, and z-amplitude columns.\n');


%% Save updated All_LFPsPerMove_Tbl_filt with computed characteristics per band

% Resave All_LFPsPerMove_Tbl_filt
cd(ephysTbl_Dir)

if useOffset && pre_offset_ms > 0 && UniformEpochs && epochDur_ms > 0
    specI_filt_outName = sprintf('bp_All_LFPsPerMove_pre%ims_post%ims.mat', pre_offset_ms, epochDur_ms);
else
    specI_filt_outName = 'bp_All_LFPsPerMove_N0offset.mat';
end

save(specI_filt_outName, "All_LFPsPerMove_Tbl_specIfilt");
fprintf('[SAVED] Bandpassed LFPsPerMove table written to %s\n', fullfile(ephysTbl_Dir, specI_filt_outName));


%% Auto-split STN depths

dorsalSTN_tbl  = All_LFPsPerMove_Tbl_specIfilt(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID,'t'),:);
centralSTN_tbl = All_LFPsPerMove_Tbl_specIfilt(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID,'c'),:);
ventralSTN_tbl = All_LFPsPerMove_Tbl_specIfilt(contains(All_LFPsPerMove_Tbl_specIfilt.move_trial_ID,'b'),:);

depthTables = struct('dorsal', dorsalSTN_tbl, 'central', centralSTN_tbl, 'ventral', ventralSTN_tbl);


%% Compute LFP power for each depth & move type

moveType_ids = unique(All_LFPsPerMove_Tbl_specIfilt.MoveType);


%% Plot PSDs for different movement contexts

% Extract LFP segments per move type per depth
% Rest, Hand OC, Arm Pro/Sup, Arm Exten/Flex


%% Run run_MovementFeatureAnalysis_IO_v2 or load kinTbl & kinSummaryTbl

cd(KinematicsDir)

% fprintf('[INFO] Loading movement data from: %s\n', MoveDataDir);
% [kinTbl, kinSummaryTbl] = run_MovementFeatureAnalysis_IO_v2(IO_DataDir, MoveDataDir, Move_CaseID);

%% FOOOF/spec param on different contexts

% * The aperiodic exponent of subthalamic field potentials reflects excitation/inhibition balance in Parkinsonism: https://pubmed.ncbi.nlm.nih.gov/36810199/; https://elifesciences.org/articles/82467#data
% * Parameterizing neural power spectra into periodic and aperiodic components: https://www.nature.com/articles/s41593-020-00744-x
% * Electrophysiological Frequency Band Ratio Measures Conflate Periodic and Aperiodic Neural Activity: https://www.eneuro.org/content/7/6/ENEURO.0192-20.2020
% * Electrophysiological Frequency Band Ratio Measures Conflate Periodic and Aperiodic Neural Activity: https://onlinelibrary.wiley.com/doi/abs/10.1111/ejn.15361
% * Time-resolved parameterization of aperiodic and periodic brain activity: Time-resolved parameterization of aperiodic and periodic brain activity | eLife
% * Subthalamic nucleus encoding steers adaptive therapies for gait in Parkinson's disease: https://www.medrxiv.org/content/10.1101/2025.08.20.25333478v1

%% Hilbert transformation spec. freq. (inst. power)

% theta band
% low-beta band
% high-beta band
% gamma band
% HFO

% at specific movement timepoints

%% Spike-field coherence

% inst. beta power at specific time/context (move index)

%% LFP bursting analysis / continuous wavelet transformation





