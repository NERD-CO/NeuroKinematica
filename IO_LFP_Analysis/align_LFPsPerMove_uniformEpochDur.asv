function All_LFPsPerMove_Tbl_uniformEpochs = align_LFPsPerMove_uniformEpochDur(Subject_AO, ProcDataDir, Move_CaseDir, ephysTbl_Dir, TTL_fs, AO_LFP_fs, pre_offset_ms, useOffset, UniformEpochs, epochDur_ms);

% IO LFP alignment and extraction script
% maps Move Index frames → TTL samples → LFP samples
% and builds All_LFPsPerMove_Tbl (per movement row)



%% Run useOffset_LFP helper function

[offset_LFP_samples, meta_Offset] = useOffset_LFP(TTL_fs, AO_LFP_fs, pre_offset_ms, useOffset);

% If useOffset == true or pre_offset_ms>0, useOffset_LFP function returns the #
% of samples to pre-pad in LFP domain based on a set pre-trial offset time
% (and a meta struct for reference).
% If useOffset == false or pre_offset_ms<=0, useOffset_LFP function returns 0.


%% Run UniformEpochs_LFP function

[epochDur_LFP_samples, meta_epochDur] = UniformEpochs_LFP(TTL_fs, AO_LFP_fs, epochDur_ms, UniformEpochs);

% If UniformEpochs == true or epochDur_ms > 0, useOffset_LFP function returns the #
% of samples to pre-pad in LFP domain based on a set pre-trial offset time
% (and a meta struct for reference).
% If UniformEpochs == false or epochDur_ms <= 0, useOffset_LFP function returns 0.


%% Define case-specific directory for movement indices per trial

cd(Move_CaseDir)

% Move_CaseDir data subfolders:
Move_CaseMats = [Move_CaseDir, filesep, 'mat folder'];      % contains processed DLC timeseries data (csv-to-mat)
Move_CaseVideos = [Move_CaseDir, filesep, 'video folder'];  % contains DLC-labeled videos and Movement Index CSVs
cd(Move_CaseVideos)

% % for kinematic analyses
% cd(Move_CaseMats)
% moveMat = dir('*.mat');
% moveMat_names = {moveMat.name};


%% Run function

cd(ProcDataDir)

% list of filename
LFPmatfiles = dir('*.mat');
LFPmatnames = {LFPmatfiles.name};

All_LFPsPerMove = cell(1, numel(LFPmatnames));

% Loop through processed LFP mat files
for LFP_mat_name = 1:length(LFPmatnames)                                    % MAT file loop

    cd(ProcDataDir)
    load(LFPmatnames{LFP_mat_name},'ProcEphys')

    % Extract a clean ProcName (matches how Subject_AO.ao_MAT_file is stored)
    fileparts = split(LFPmatnames{LFP_mat_name},'_');
    ProcName = fileparts{2};
    ProcFile = LFPmatnames{contains(LFPmatnames, ProcName)};

    % In Subject_AO, find ao_MAT_file that corresponds with trial
    SubjectAO_row = Subject_AO(contains(Subject_AO.ao_MAT_file, ProcName),:);

    % Define motor trial ID string (depth_trialNum)
    switch SubjectAO_row.stn_loc{1}(1)
        case 'd'
            depthName = 't'; % dorsal
        case 'v'
            depthName = 'b'; % ventral
        otherwise
            depthName = 'c'; % central
    end
    motor_trial_ID = [depthName, num2str(SubjectAO_row.trialNum),'_', SubjectAO_row.depth{1}];

    % Generate list of Motor Index CSVs
    cd(Move_CaseVideos)
    moveCSV = dir('*.csv');
    moveCSV_names = {moveCSV.name};
    moveCSV = moveCSV_names(contains(moveCSV_names,'Move')); % filter for CSVs that contain 'Move' string
    if ~any(contains(moveCSV, motor_trial_ID))  % checking if logical is false
        continue
    end
    moveTbl_name = moveCSV{contains(moveCSV, motor_trial_ID)};
    moveTbl = readtable(moveTbl_name); % load movement index CSV in mat table form

    % clean moveTbl (remove zeros)
    LFPsMoveTbl = moveTbl(cellfun(@(X) ~isempty(X), moveTbl.MoveType, 'UniformOutput', true),:);

    % temp var
    LFP_move_trial_ID = [ProcName,'_', motor_trial_ID];

    % initiate an LFPs per Electrode per MAT accumulator table
    nRows_LFPMoveTbl = height(LFPsMoveTbl);
    LFPs_perE_perMAT = table();

    % Define All_LFPsPerMove tbl fields
    LFPs_perE_perMAT.MoveN        = LFPsMoveTbl.MoveN;
    LFPs_perE_perMAT.MoveType     = LFPsMoveTbl.MoveType;
    LFPs_perE_perMAT.BeginF       = LFPsMoveTbl.BeginF;
    LFPs_perE_perMAT.EndF         = LFPsMoveTbl.EndF;
    LFPs_perE_perMAT.move_trial_ID = repmat({motor_trial_ID}, nRows_LFPMoveTbl, 1);
    LFPs_perE_perMAT.LFP_trial_ID = repmat({ProcName}, nRows_LFPMoveTbl, 1);


    % Define TTL fields of interest
    TTL_Down = ProcEphys.TTL.Down; % voltage deflection, frames -> TTL sample index (1 cell represents frame#, values within the cell represent sample#s)
    TTL_clockStart = ProcEphys.TTL.startTime; % in seconds

    % Robust accessor: works for cell, table, or numeric TTL_Down
    if iscell(TTL_Down)
        getTTL = @(i) TTL_Down{i};
    elseif istable(TTL_Down)
        % if someone saved TTL as a 1-col table, use the first variable
        firstVar = TTL_Down.Properties.VariableNames{1};
        getTTL = @(i) TTL_Down{i, firstVar};
    else
        % numeric or vector
        getTTL = @(i) TTL_Down(i);
    end


    % account for mult. electrode channels
    electrode_names = fieldnames(ProcEphys.LFP); % get num (E#)

    % Loop through each electrode channel per processed LFP mat file        % Electrode Loop
    for e_i = 1:numel(electrode_names)
        E_chName = electrode_names{e_i};

        % dynamically index within struct
        LFP_raw = ProcEphys.LFP.(E_chName).rawData; % vector of raw voltage
        AO_startTime = ProcEphys.LFP.(E_chName).startTime; % time in seconds

        % clock offset: Precompute TTL → AO/LFP samples (seconds → samples)
        sample_offset = round((TTL_clockStart - AO_startTime) * AO_LFP_fs);

        % Preallocate start/end index vectors (one per movement row)
        TTL_LFP_idx_Start = nan(nRows_LFPMoveTbl, 1);
        TTL_LFP_idx_End   = nan(nRows_LFPMoveTbl, 1);
        LFPs_in_moveSeg = cell(nRows_LFPMoveTbl, 1);


        % loop through trials, extract BeginF + EndF indices in each MoveIndex CSV
        for move_i = 1:nRows_LFPMoveTbl                                     % MoveTrial Loop
            % Frame indices from Move Index table
            frame_startTime = LFPsMoveTbl.BeginF(move_i);
            frame_endTime   = LFPsMoveTbl.EndF(move_i);

            % TTL samples at frame boundaries (TTL domain, wrt AO clock)
            ttl_start = getTTL(frame_startTime);
            ttl_end   = getTTL(frame_endTime);

            % TTL domain → AO/LFP domain (samples)
            TTL_samp_taskStart = round((ttl_start/TTL_fs) * AO_LFP_fs);
            TTL_samp_taskEnd   = round((ttl_end  /TTL_fs) * AO_LFP_fs);

            % Apply clock offset and pre-offset
            s0_taskStart_offset = TTL_samp_taskStart + sample_offset - offset_LFP_samples;  % start (50 ms pre MoveRep start)
            % sn_taskEnd_offset = TTL_samp_taskEnd + sample_offset; % end
            sn_taskEnd_offset = TTL_samp_taskStart + sample_offset + epochDur_LFP_samples;  % end (1000 ms post MoveRep start)

            % Clamp to LFP array bounds
            s0 = max(1, min(s0_taskStart_offset, numel(LFP_raw)));
            sn = max(1, min(sn_taskEnd_offset, numel(LFP_raw)));
            if sn < s0
                % Optional: log skip; for now just continue
                continue
            end

            % Store the (clamped) indices as your official start/end
            TTL_LFP_idx_Start(move_i) = s0;
            TTL_LFP_idx_End(move_i)   = sn;

            % Extract LFPs in Movement Segment
            LFPs_in_moveSeg{move_i} = LFP_raw(s0:sn);

            % Write to table cell
            % LFPsMoveTbl.LFPs{move_i} = LFPs_in_moveSeg;
        end

        % write columns for this electrode
        % derive a clean tag, e.g., 'E1'
        E_token = regexp(E_chName, '(E[0-9A-Za-z]+)$', 'tokens', 'once');
        if ~isempty(E_token)
            elecTag = E_token{1};
        else
            elecTag = regexprep(E_chName,'\W','');
        end
        LFPs_perE_perMAT.(['LFP_', elecTag]) = LFPs_in_moveSeg;
        % LFPs_perE_perMAT.(['TTL_LFP_idx_Start_', elecTag]) = TTL_LFP_idx_Start;
        % LFPs_perE_perMAT.(['TTL_LFP_idx_End_',   elecTag]) = TTL_LFP_idx_End;

    end

    % Add TTL_LFP_idx_Start and TTL_LFP_idx_End columns
    LFPs_perE_perMAT.TTL_LFP_idx_Start = TTL_LFP_idx_Start;
    LFPs_perE_perMAT.TTL_LFP_idx_End = TTL_LFP_idx_End;

    % Create LFPs per Electrode per MAT table
    All_LFPsPerMove{LFP_mat_name} = LFPs_perE_perMAT;

end

%% Align columns across MATs and concatenate

% union of vars
allVars = {};
for t_i = 1:numel(All_LFPsPerMove)
    if istable(All_LFPsPerMove{t_i})
        allVars = union(allVars, All_LFPsPerMove{t_i}.Properties.VariableNames, 'stable');
    end
end
allVars = string(allVars); % the union of all column names seen across all tables

% fill missing columns with sensible types, reorder, then vertcat
for tbl_i = 1:numel(All_LFPsPerMove)
    tempTbl = All_LFPsPerMove{tbl_i};
    if ~istable(tempTbl), continue; end % Skip this entry if it isn't actually a table
    have = string(tempTbl.Properties.VariableNames); % Extract current col names
    missing = setdiff(allVars, have, 'stable'); % Compute which cols are missing compared to allVars
    for m_i = 1:numel(missing)
        varN = missing(m_i);
        if startsWith(varN, "LFP_")
            tempTbl.(varN) = cell(height(tempTbl),1);
        elseif startsWith(varN, "TTL_LFP_idx_")
            tempTbl.(varN) = nan(height(tempTbl),1);
        else
            % default flexible type
            tempTbl.(varN) = cell(height(tempTbl),1);
        end
    end
    tempTbl = tempTbl(:, allVars);  % reorder cols to match allVars order
    All_LFPsPerMove{tbl_i} = tempTbl;
end

% vertically concatenate all perMAT tables into one big table
All_LFPsPerMove_Tbl = vertcat(All_LFPsPerMove{cellfun(@istable, All_LFPsPerMove)}); % one row per movement; electrodes as columns


%% Define the standard column order

standard_col_order = {'MoveN', 'MoveType', 'BeginF', 'EndF', 'move_trial_ID', 'LFP_trial_ID', 'TTL_LFP_idx_Start', 'TTL_LFP_idx_End'};
Tblvars = string(All_LFPsPerMove_Tbl.Properties.VariableNames);
elecs = unique(regexprep(Tblvars(startsWith(Tblvars,"LFP_")), '^LFP_',''), 'stable');
lfp_cols = "LFP_" + elecs;

want = [standard_col_order, lfp_cols];
have = string(All_LFPsPerMove_Tbl.Properties.VariableNames);
rest = setdiff(have, want, 'stable');
All_LFPsPerMove_Tbl = All_LFPsPerMove_Tbl(:, [intersect(want, have, 'stable'), rest]);


%% save All_SpikesPerMove_Tbl and meta_Offset to files

cd(ephysTbl_Dir)

if useOffset && pre_offset_ms > 0
    outName = sprintf('All_LFPsPerMove_offset%ims.mat', pre_offset_ms);
else
    outName = 'All_LFPsPerMove_N0offset.mat';
end

save(outName, "All_LFPsPerMove_Tbl");

save("Offset_meta_struct", "meta_Offset")


end

%% Notes:

% MacroLFP = MLFP in processed mat (recorded from macro contact)
% CLFP = LFP in processed mat (recorded from tip / micro)


%% Helper Functions

function [offset_LFP_samples, meta_Offset] = useOffset_LFP(TTL_fs, AO_LFP_fs, pre_offset_ms, useOffset)

% useOffset_LFP
% Returns # of samples to pre-pad in LFP domain based on pre-offset time.
% If useOffset == false or pre_offset_ms<=0, Returns 0.

% OUT:
%   offset_LFP_samp : integer samples in LFP domain to subtract from start
%   meta_Offset     : struct with .ms, .seconds, .ttl_samples, .lfp_samples

if nargin < 4 || isempty(useOffset), useOffset = true; end

meta_Offset.ms       = pre_offset_ms;
meta_Offset.seconds  = pre_offset_ms/1000;
if ~useOffset || pre_offset_ms <= 0
    meta_Offset.ttl_samples = 0;
    meta_Offset.lfp_samples = 0;
    offset_LFP_samples  = 0;
    return
end

% For completeness, keep both TTL and LFP counts available in meta
meta_Offset.ttl_samples = round(TTL_fs * meta_Offset.seconds);
meta_Offset.lfp_samples = round(AO_LFP_fs * meta_Offset.seconds);

% What we actually need when indexing LFP data:
offset_LFP_samples  = meta_Offset.lfp_samples;
end


function [epochDur_LFP_samples, meta_epochDur] = UniformEpochs_LFP(TTL_fs, AO_LFP_fs, epochDur_ms, UniformEpochs)

% UniformEpochs_LFP
% Returns # of samples to pad in LFP domain (after trial start)
% based on uniform epoch duration time.
% If UniformEpochs_LFP == false or epochDur_ms <= 0, Returns 0.

% OUT:
%   epochDur_LFP_samples : integer samples in LFP domain to add from start
%   meta_epochDur        : struct with .ms, .seconds, .ttl_samples, .lfp_samples

if nargin < 4 || isempty(UniformEpochs), UniformEpochs = true; end

meta_epochDur.ms = epochDur_ms;
meta_epochDur.seconds = epochDur_ms/1000;

if ~UniformEpochs || epochDur_ms <= 0
    meta_epochDur.ttl_samples = 0;
    meta_epochDur.lfp_samples = 0;
    epochDur_LFP_samples  = 0;
    return
end

% For completeness, keep both TTL and LFP counts available in meta
meta_epochDur.ttl_samples = round(TTL_fs * meta_epochDur.seconds);
meta_epochDur.lfp_samples = round(AO_LFP_fs * meta_epochDur.seconds);

% What we actually need when indexing LFP data:
epochDur_LFP_samples = meta_epochDur.lfp_samples;

end