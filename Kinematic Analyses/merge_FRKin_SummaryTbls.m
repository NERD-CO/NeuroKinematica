function merge_FRKin_SummaryTbls(IO_DataDir, ephysTbl_Dir, ephys_offset, MoveDir_CaseID, FR_SummaryTbl, kinSummaryTbl)

% run_FR_KinematicCorr  Correlate per‐trial firing rates with kinematic features.
%
% This function loads spike-per-move tables and kinematic data, computes correlations,
% and writes a master CSV containing trial-level data along with correlation metrics.
% Additionally, it generates scatter plots with linear fits.


%% ==== TOGGLE OPTIONS ====

useActualDuration = false;      % false = fixed window_FR Option B
window_FR         = [-0.05 0.45]; % FR window (s) for Option B
AO_spike_fs       = 44000;      % sampling rate

outlierStrategy   = 'remove';   % 'remove' | 'flag'
logTransformFR    = false;      % log‐transform FR if heavy‐tailed
logTransformKin   = false;      % log‐transform kin features
zscoreFR          = false;      % z‐score FR before correlation
zscoreKin         = false;      % z‐score kin features
useSpearman       = false;      % fallback to Spearman if non‐normal


%% Output directories

output_CorrDir      = fullfile(ephysTbl_Dir,'FR_Kinematics');
output_kinAnalysisDir = fullfile(IO_DataDir, 'Kinematic Analyses', MoveDir_CaseID);
if ~exist(output_CorrDir,'dir'), mkdir(output_CorrDir); end

%% Confirm FR summary generated by run_IO_FR_Analysis_and_Plotting 

% Load spike‐per‐trial table 
cd(ephysTbl_Dir);
allSPKmats = dir('*Spikes*.mat');
allSPKnames = {allSPKmats.name};
if ephys_offset
    matfile = allSPKnames{contains(allSPKnames,'offset') & contains(allSPKnames,'Spikes')};
else
    matfile = allSPKnames{~contains(allSPKnames,'offset') & contains(allSPKnames,'Spikes')};
end
load(matfile,'All_SpikesPerMove_Tbl');

% disp('FR_SummaryTbl columns:');
% disp(FR_SummaryTbl.Properties.VariableNames);


%% Confirm kinematic feature summary generated by run_MovementFeatureAnalysis_IO_v2

cd(output_kinAnalysisDir)
% disp('kinSummaryTbl columns:');
% disp(kinSummaryTbl.Properties.VariableNames);

% Split TrialID into components
% splitTrialID = cellfun(@(x) split(x, '_'), kinSummaryTbl.TrialID, 'UniformOutput', false);

[CaseDate, MoveTrialID] = arrayfun(@extract_MoveTrialID, kinSummaryTbl.TrialID, 'UniformOutput', false);

% Append to kinSummaryTbl
kinSummaryTbl.CaseDate = CaseDate;
kinSummaryTbl.MoveTrialID = MoveTrialID;

% disp('updated kinSummaryTbl columns:');
% disp(kinSummaryTbl.Properties.VariableNames);

%% Merge kinSummaryTbl with FR_SummaryTbl using MoveTrialID and MoveType

% Normalize key types before the join (string vs cellstr)
FR_SummaryTbl.MoveTrialID = string(FR_SummaryTbl.MoveTrialID);
FR_SummaryTbl.MoveType    = string(FR_SummaryTbl.MoveType);

kinSummaryTbl.MoveTrialID = string(kinSummaryTbl.MoveTrialID);
kinSummaryTbl.MoveType    = string(kinSummaryTbl.MoveType);

% create master table
masterTbl = innerjoin(FR_SummaryTbl, kinSummaryTbl, 'Keys', {'MoveTrialID', 'MoveType'});

% Quick diagnostics (optional)
nFR  = numel(unique(FR_SummaryTbl.MoveTrialID));
nKin = numel(unique(kinSummaryTbl.MoveTrialID));
fprintf('[CHECK] Unique MoveTrialID: FR=%d, Kin=%d\n', nFR, nKin);

% Display the result of the join (masterTbl)
% disp('masterTbl columns:');
% disp(masterTbl.Properties.VariableNames);

% Optionally, save the merged table as a CSV
writetable(masterTbl, 'Merged_FR_Kin_Summary.csv');


%% Transforms & outlier handling, if needed
% 
% % Identify numeric columns for outlier detection 
% numericVars = varfun(@isnumeric, masterTbl, 'OutputFormat', 'uniform');
% numericCols = masterTbl(:, numericVars);
% 
% % Remove outliers if 'remove' strategy is selected
% if strcmpi(outlierStrategy, 'remove')
%     ok = all(~isoutlier(numericCols{:,:}), 2);
%     masterTbl = masterTbl(ok, :);
% end
% 
% % Log-transform if flagged
% if logTransformFR
%     masterTbl.FR_Hz = log(masterTbl.FR_Hz + eps);
% end
% if logTransformKin
%     kinCols = setdiff(masterTbl.Properties.VariableNames, {'MoveTrialID', 'FR_Hz'});
%     masterTbl{:, kinCols} = log(masterTbl{:, kinCols} + eps);
% end
% 
% % Z-score if flagged
% if zscoreFR
%     masterTbl.FR_Hz = zscore(masterTbl.FR_Hz);
% end
% if zscoreKin
%     kinCols = setdiff(masterTbl.Properties.VariableNames, {'MoveTrialID', 'FR_Hz'});
%     masterTbl{:, kinCols} = zscore(masterTbl{:, kinCols});
% end


end

%% Helper Function

function [CaseDate, MoveTrialID] = extract_MoveTrialID(TrialID)
% extract_MoveTrialID - Extract CaseDate and MoveTrialID from TrialID string

% Handles:
%   20230323_b1_d1p06_session001
%   20230518_LH_b1_d0p18_session001
%   20230823_R_b1_d2p6_session001

% Default values
CaseDate = '';
MoveTrialID = '';

% Normalize input
TrialID = char(string(TrialID));

% date + optional hemisphere ([LR]H or single [LR]) + block/depth + session
% Named-token pattern; hemisphere is optional
pat = '^(?<date>20\d{6})_(?:(?<hemi>[LR]H|[LR])_)?(?<mov>[bct]\d+_d\d+p\d+)_session\d+$';

% Try case-sensitive first, then case-insensitive
m = regexp(TrialID, pat, 'names');
if isempty(m)
    m = regexpi(TrialID, pat, 'names');  % ignore case if needed
end

if ~isempty(m)
    CaseDate    = string(m.date);
    MoveTrialID = string(m.mov);
else
    warning('[WARN] Unrecognized TrialID format: %s', string(TrialID));
    % leave outputs as "", which plays nicely with join/type coercion later
end

% tokensA = regexp(TrialID, '^(20\d{6})_([bct]\d+_d\d+p\d+)_session\d+$', 'tokens'); % Format A: "20230323_b1_d1p06_session001"
% tokensB = regexp(TrialID, '^(20\d{6})_([LR]H)_([bct]\d+_d\d+p\d+)_session\d+$', 'tokens'); % Format B: "20230518_LH_b1_d0p18_session001"
% if ~isempty(tokensA)
%     CaseDate = tokensA{1}{1};
%     MoveTrialID = tokensA{1}{2};
% elseif ~isempty(tokensB)
%     CaseDate = tokensB{1}{1};
%     MoveTrialID = tokensB{1}{3};  % Note: tokensB{1}{2} is Hemisphere
% else
%     warning('[WARN] Unrecognized TrialID format: %s', TrialID);
% end

end

